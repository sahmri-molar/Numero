// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <Rcpp.h>
#include <vector>
#include <string>
#include <iostream>
#include <unordered_map>
#include "medusa.hpp"
#include "commonFunction.h"

using namespace std;
using namespace Rcpp;
using namespace medusa;

// import file function
static List numero_import(string fileName, vector<string> vars, vector<string> keyvars, string keyback );

// export to R
// [[Rcpp::export]]
RcppExport SEXP nroImportFile( SEXP fileName_R, SEXP vars_R, SEXP kvars_R, SEXP keyFb_R ) {
  string fname = as<string>( fileName_R );
  vector<string> vars = as<vector<string> >( vars_R );
  vector<string> keyvars = as<vector<string> >( kvars_R );
  string keyback = as<string>( keyFb_R );

  // check if vars and kvars is empty
  if( vars.size() == 1 && vars.at( 0 ) == "" ){
    vars.clear();
    vars.resize( 0 );
  }

  if( keyvars.size() == 1 && keyvars.at( 0 ) == "" ){
    keyvars.clear();
    keyvars.resize( 0 );
  }

  List result = numero_import( fname, vars, keyvars, keyback );

  return wrap( result );
}


// import file function
List numero_import( string fname, vector<string> vars, vector<string> keyvars, string keyback ){
  mdreal rlnan = NAN;

  /* Open file. */
  File f; f.open(fname, "r");
  if(f.error().size() > 0){
    cout<<f.error().c_str()<<endl;
    return List::create( "Error!" );
  }

  /* Import headings. */
  unordered_map<string, mdsize> head2col;
  vector<string> headings = f.read('\t', 0);
  for(mdsize j = 0; j < headings.size(); j++) {
    string& head = headings[j];
    if(head2col.count(head) > 0) continue;
    if(head.size() > 0) {
      head2col[head] = j;
      continue;
    }
    cout<<"Empty heading in \""<<fname<<"\"."<<endl;
    return List::create( "Error!" );
  }

  /* Check if duplicate headings. */
  if(head2col.size() != headings.size()) {
    cout<<"Duplicate headings in \""<<fname<<"\"."<<endl;
    return List::create( "Error!" );
  }

  /* Set selection mask. */
  vector<mdsize> cols;
  if(vars.size() < 1) vars = headings;
  for(mdsize j = 0; j < vars.size(); j++) {
    string& name = vars[j];
    if(head2col.count(name) < 1) continue;
    vars[cols.size()] = name;
    cols.push_back(head2col[name]);
  }

  /* Check if any usable variables. */
  vars.resize(cols.size());
  if(vars.size() < 1) {
    cout<<"No usable data in \""<<fname<<"\"."<<endl;
    return List::create( "Error!" );
  }

  /* Set identity mask. */
  vector<mdsize> keycols;
  for(mdsize j = 0; j < keyvars.size(); j++) {
    string& name = keyvars[j];
    if(head2col.count(name) > 0) {
      keycols.push_back(head2col[name]);
      continue;
    }
    cout<<"Insufficient identity data in \""<<fname<<"\"."<<endl;
    return List::create( "Error!" );
  }

  /* Try fallback identity. */
  if((keycols.size() < 1) && (head2col.count(keyback) > 0))
    keycols.push_back(head2col[keyback]);

  /* First row is empty. This is to avoid problems with
     the output arguments. */
  vector<string> keys(1);
  vector<vector<mdreal> > data(1);
  data[0].resize(cols.size(), rlnan);

  /* Collect data values. */
  for(unsigned long nlines = 1; f.error().size() < 1; nlines++) {
    vector<mdreal> values(cols.size(), rlnan);
    vector<string> fields = f.read('\t', 0);
    mdsize nfields = fields.size();
    if(nfields < 1) continue;

    /* Create identity. */
    string key;
    for(mdsize k = 0; k < keycols.size(); k++) {
      mdsize ind = keycols[k];
      if(ind < nfields) {
	if(fields[ind].size() > 0) {
	  key += (fields[ind] + "\t");
	  continue;
	}
      }
      cout<<"Unusable identity in \""<<fname<<"\"."<<endl;
      return List::create( "Error!" );
    }   
    
    /* Default identity. */
    mdsize len = key.size();
    if(len < 1) key = long2string(nlines);
    else key.resize(len - 1); /* trailing delimiter */


    /* Copy row vector. */
    for(mdsize k = 0; k < cols.size(); k++) {
      mdsize ind = cols[k];
      if(ind >= nfields) continue;
      values[k] = string2real(fields[ind]);
    }

    /* Update dataset. */
    data.push_back(values);
    keys.push_back(key);
  }

  // convert vector of vector to dataframe
  List dataList(data.size());
  CharacterVector namevec;
  for( int i = 0; i < data.size(); i++ ){
    dataList[ i ] = data.at( i ); // adding vectors
    namevec.push_back( itos( i ) ); // making up column names
  }
  dataList.attr("names") = namevec;
  DataFrame df( dataList );

  // convert vector of vector to matrix
  /*NumericMatrix df( data.size(), vars.size() );
  for( int i = 0; i < data.size(); i++ ){
    for( int j = 0; j < data.at( i ).size(); j++ ){
      df( i, j ) = data.at( i ).at( j );
    }
  }
  */

  List result = List::create( df, vars, keys );
  return result;
}
